1) Il team di sviluppo di un azienda consiste di un senior software engineer e due sviluppatori junior. Usando un approccio agile, ogni iterazione impegna tutti e tre i membri del team per un mese ed occorrono tre iterazioni per completare lo sviluppo. Si assuma che non ci siano "change requests" e che il membro senior costi A Eur/mese ed i membri junior B Eur/mese. Qual'e' il costo dello sviluppo usando un approccio agile ?


A + 2*B

OK 3*(A + 2*B)


3*A + 2*B


2) Si consideri un software sviluppato seguendo un approccio plan-driven implementato con tre fasi: F1, F2, F3. Dopo ogni fase c'e' una probabilità p di dover ripeter la fase precedente ed una probabilità (1 - p) di passare alla fase successiva (sino ad arrivare al termine dello sviluppo). Quale delle seguenti catene di Markov modella il processo software descritto sopra?

1 OK


3)La validazione risponde alla seguenete domanda:

Sono soddisfatti i requisti funzionali ?

Stiamo costruendo il sistema nel modo giusto ?

OK Stiamo costruendo il sistema giusto ?




4)Si consideri un software sviluppato seguendo un approccio iterativo implementato con due fasi: F1 seguita da F2. Ciascuna fase ha costo A. Con probabilità p potrebbe essere necessario ripetere F1 una seconda volta.  Con probabilità q potrebbe essere necessario ripetere F2 una seconda volta. Qual'e' il costo atteso dello sviluppo dell'intero software?


OK A*(2 + p +q)

A*(1 + p +q)

A*(3 + p +q)



5)Quali delle seguenti attività può contribuire a validare i requisiti di un sistema ?

OK Costruire un prototipo, metterlo in esercizio ed accertarsi che i porti i benefici attesi.

Costruire un prototipo e testarlo a fondo per evidenziare subito errori di implementazione.

Costruire un prototipo e valutarne attentamente le performance.



6)Quale delle seguenti affermazione è vera riguardo al beta testing ?

OK Una release del software è resa disponibile agli utenti (beta users) per permettergli di sperimentare e quindi segnalare eventuali problemi rilevati agli sviluppatori.

Test automatizzato sono eseguiti sulla versione finale del sistema presso il cliente.

Test automatizzato sono eseguiti sulla versione finale del sistema presso il sito di sviluppo del software.



7) Il component testing si concentra su:

OK Testare le interfacce per ciascun componente.

Testare funzionalità di unità software individuali, oggetti, classi o metodi.

Testare l'interazione tra molte componenti (cioè integrazione di molte unità).



8) Un sistema consiste di tre componenti C1, C2, C3 connesse in una architettura ad anello dove l'output della componente C1 (rispettivamente C2, C3) è mandato all'input della componente C2 (rispettivamente C3, C1). Quale dei seguenti schemi Modelica meglio rappresenta l'architettura descritta ?


OK 
connector InputInteger = input Integer;

connector OutputInteger = output Integer;

block C1

InputInteger u;

OutputInteger x;

...

end C1;

block C2

InputInteger u;

OutputInteger x;

...

end C2;

block C3

InputInteger u;

OutputInteger x;

...

end C3;

class System

C1 k1;

C2 k2;

C3 k3;

equation

connect(k1.x, k2.u);

connect(k2.x, k3.u);

connect(k3.x, k1.u);

end System;



connector InputInteger = input Integer;

connector OutputInteger = output Integer;

block C1

InputInteger u;

OutputInteger x;

...

end C1;

block C2

InputInteger u;

OutputInteger x;

...

end C2;

block C3

InputInteger u;

OutputInteger x;

...

end C3;

class System

C1 k1;

C2 k2;

C3 k3;

equation

connect(k1.x, k1.u);

connect(k2.x, k2.u);

connect(k3.x, k3.u);

end System;


connector InputInteger = input Integer;

connector OutputInteger = output Integer;

block C1

InputInteger u;

OutputInteger x;

...

end C1;

block C2

InputInteger u;

OutputInteger x;

...

end C2;

block C3

InputInteger u;

OutputInteger x;

...

end C3;

class System

C1 k1;

C2 k2;

C3 k3;

equation

connect(k1.x, k3.u);

connect(k3.x, k2.u);

connect(k2.x, k1.u);

end System;




9) Il team di sviluppo di un azienda consiste di un senior software engineer e due sviluppatori junior. Usando un approccio plan-driven (ad esempio, water-fall) la fase di design impegna solo il membro senior per tre mesi e la fase di sviluppo e testing solo i due membri junior per tre mesi. Si assuma che non ci siano "change requests" e che il membro senior costi A Eur/mese ed i membri junior B Eur/mese. Qual'e' il costo dello sviluppo usando un approccio plan-driven come sopra ?

3*A + 3*B

A + 2*B

OK 3*A + 6*B


10) Quale delle seguenti affermazioni è vera riguardo all'alpha testing ?

Test automatizzati sono eseguiti sulla prima release del sistema.

Test automatizzati sono eseguiti su una versione preliminare del sistema.

OK Gli utenti del sistema lavorano insieme al team di sviluppo per testare il software nel sito di sviluppo.



11) Un processo di sviluppo agile consiste di 3 iterazioni identiche di costo A. Alla fine di ogni iterazione vengono prese in considerazione le "change requests" e, se ve ne sono, l'iterazione viene ripetuta. Sia p la probabilità che ci siano "change requests" all fine di una iterazione. Il valore atteso del costo del progetto è:


3*(A + p)


OK 3*(1 + p)*A

3*p*A


12) Una azienda vende software utilizzando un contratto di Service Level Agreement (SLA) per cui l'utente paga 1000 Eur al mese di licenza e l'azienda garantisce che il software sia "up and running". Questo vuol dire che failures del software generano un costo (quello del repair). Sia C = 10000 Eur il costo del repair di una failure e R = P*C il valore atteso (rischio) del costo dovuto alle failures (dove P è la probabilità di una software failure). Ovviamente affinché il business sia profittevole deve essere che R sia al più 1000 Eur. Qual'e' il valore massimo di P che garantisce la validità del modello di business di cui sopra ?


1. OK
P = 1/10

2.
P = 1/1000

3.
P=1/10000





13) Il rischio R può essere calcolato come R = P*C, dove P è la probabilità dell'evento avverso (software failure nel nostro contesto) e C è il costo dell'occorrenza dell'evento avverso. Assumiamo che la probabilità P sia legata al costo di sviluppo S dalla formula P = exp(-b*S), dove b è una opportuna costante note da dati storici aziendali. Quale sarà il costo dello sviluppo S di un software il cui costo della failure è C ed il rischio ammesso è R?

Scegli un'alternativa:

1.
S = (1/b)*ln(R/C)

2. OK
S = (1/b)*ln(C/R)

3.
S = b*ln(R/C)



14) Si consideri la seguente Markov Chain:
FOTO

Quale dei seguenti modelli Modelica fornisce un modello ragionevole per la Markov Chain di cui sopra?

Scegli un'alternativa:

1.


model System

parameter Integer F1 = 1;

parameter Integer F2 = 2;

parameter Integer F3 = 3;

parameter Integer End = 4;

parameter Real p = 0.3;

parameter Real A[4, 4] =

[

p, 0 , 1-p, 0;

p, 1-p, 0, 0;

p, 0, 0, 1-p;

0, 0, 0, 1

];

Integer x;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

x := F1;

r1024 := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

if (r1024 <= A[x, F1]) then

 x := F1;

 elseif (r1024 <= A[x, F1] + A[x, F2]) then

 x := F2;

 elseif (r1024 <= A[x, F1] + A[x, F2] + A[x, F3]) then

 x := F3;

 else

 x := End;

end if;

end when;

end System;




2. OK


model System

parameter Integer F1 = 1;

parameter Integer F2 = 2;

parameter Integer F3 = 3;

parameter Integer End = 4;

parameter Real p = 0.3;

parameter Real A[4, 4] =

[

p, 1-p, 0, 0;

p, 0, 1-p, 0;

p, 0, 0, 1-p;

0, 0, 0, 1

];

Integer x;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

algorithm

when initial() then

   state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

   x := F1;

   r1024 := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

if (r1024 <= A[x, F1]) then

 x := F1;

 elseif (r1024 <= A[x, F1] + A[x, F2]) then

 x := F2;

 elseif (r1024 <= A[x, F1] + A[x, F2] + A[x, F3]) then

 x := F3;

 else

 x := End;

end if;

end when;

end System;




3.
model System

parameter Integer F1 = 1;

parameter Integer F2 = 2;

parameter Integer F3 = 3;

parameter Integer End = 4;

parameter Real p = 0.3;

parameter Real A[4, 4] =

[

p, 0, 1-p, 0;

0, p, 1-p, 0;

p, 0, 0, 1-p;

0, 0, 0, 1

];

Integer x;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

x := F1;

r1024 := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

if (r1024 <= A[x, F1]) then

 x := F1;

 elseif (r1024 <= A[x, F1] + A[x, F2]) then

 x := F2;

 elseif (r1024 <= A[x, F1] + A[x, F2] + A[x, F3]) then

 x := F3;

 else

 x := End;

end if;

end when;

end System;



15) Un azienda ha un team di sviluppo in cui il 90% dei membri è junior (cioè con poca esperienza) ed il 10% è senior (cioè con molta esperienza).  Con l'obiettivo di massimizzare il numero di progetti completati nell'unità di tempo, quale dei seguenti modelli di sviluppo software appare più opportuno.

Scegli un'alternativa:

1.
Basato sul riuso

2. OK
Plan driven

3.
Iterativo



16) Un sistema consiste di due sottosistemi: un controller ed un plant (sistema controllato). Il controllore misura l'output del plant e manda comandi al plant in accordo. Quale dei seguenti schemi Modelica modella l'architettura di sistema descritta sopra ?



Scegli un'alternativa:

1. OK
connector InputInteger = input Integer;

connector OutputInteger = output Integer;

block Controller

InputInteger x;

OutputInteger Integer w;

...

end Controller;

block Plant

InputInteger u;

OutputInteger y;

...

end Plant;

class System

Controller k;

Plant p;

equation

connect(p.y, k.x);

connect(k.w, p.u);

end System;


2.
connector InputInteger = input Integer;

connector OutputInteger = output Integer;

block Controller

InputInteger x;

OutputInteger Integer w;

...

end Controller;

block Plant

InputInteger u;

OutputInteger y;

...

end Plant;

class System

Controller k;

Plant p;

equation

connect(p.y, p.u);

connect(k.w, k.u);

end System;



3.
connector InputInteger = input Integer;

connector OutputInteger = output Integer;

block Controller

InputInteger x;

OutputInteger Integer w;

...

end Controller;

block Plant

InputInteger u;

OutputInteger y;

...

end Plant;

class System

Controller k;

Plant p;

equation

connect(p.y, k.w);

connect(k.x, p.u);

end System;



17) Si consideri il monitor seguente che ritorna true appena i requisiti per il sistema monitorato sono violati.

//block Monitor

input Real x;  

output Boolean y;

Boolean w;

initial equation

y = false;

equation

w = ((x < 0) or (x > 5));

algorithm

when edge(w) then

y := true;

end when;

end Monitor;//

Quale delle seguenti affermazioni meglio descrive il requisito monitorato.

Scegli un'alternativa:

1.
La variable x è minore di 0.


2. OK
La variabile x è fuori dall'intervallo [0, 5].


3.
La variabile x è nell'intervallo [0, 5].



18) Si pianifica lo sviluppo di un sistema software per controllare il sistema di anti-lock braking in un automobile. Quale dei seguenti è il tipico processo software usato per questo tipo di sistema software ?



Scegli un'alternativa:

1. OK
Sviluppo Plan-driven.


2.
Sviluppo Iterativo.


3.
Extreme programming.




19) Focalizzandosi sui metodi agile di sviluppo del software, quale delle seguenti affermazioni è vera?


Scegli un'alternativa:

1.
Per evitare di sprecare tempo durante la fase di sviluppo del software, il customer non è mai coinvolto nel processo di sviluppo del software.

2. OK
Le attività di definizione dei requisiti e di sviluppo sono interleaved.


3.
Per evitare di sprecare tempo durante la fase di sviluppo del software, questa inizia solo quando i requisiti sono stati completamente definiti. 



20) Si consideri la seguente Markov Chain:
FOTO

Quale dei seguenti modelli Modelica fornisce un modello ragionevole per la Markov Chain di cui sopra?

Scegli un'alternativa:

1.
model System

parameter Integer F1 = 1;

parameter Integer F2 = 2;

parameter Integer F3 = 3;

parameter Integer End = 4;

parameter Real p = 0.3;

parameter Real A[4, 4] =

[

0, 1, 0, 0;

p, 1-p, 0, 0;

0, 0, p, 1-p;

0, 0, 0, 1

];

Integer x;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

x := F1;

r1024 := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

if (r1024 <= A[x, F1]) then

 x := F1;

 elseif (r1024 <= A[x, F1] + A[x, F2]) then

 x := F2;

 elseif (r1024 <= A[x, F1] + A[x, F2] + A[x, F3]) then

 x := F3;

 else

 x := End;

end if;

end when;

end System;


2. OK


model System

parameter Integer F1 = 1;

parameter Integer F2 = 2;

parameter Integer F3 = 3;

parameter Integer End = 4;

parameter Real p = 0.3;

parameter Real A[4, 4] =

[

0, 1, 0, 0;

p, 0, 1-p, 0;

0, p, 0, 1-p;

0, 0, 0, 1

];

Integer x;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

algorithm

when initial() then

   state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

   x := F1;

   r1024 := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

if (r1024 <= A[x, F1]) then

 x := F1;

 elseif (r1024 <= A[x, F1] + A[x, F2]) then

 x := F2;

 elseif (r1024 <= A[x, F1] + A[x, F2] + A[x, F3]) then

 x := F3;

 else

 x := End;

end if;

end when;

end System;




3.
model System

parameter Integer F1 = 1;

parameter Integer F2 = 2;

parameter Integer F3 = 3;

parameter Integer End = 4;

parameter Real p = 0.3;

parameter Real A[4, 4] =

[

0, 1, 0, 0;

p, 0, 0, 1-p;

0, 0, p, 1-p;

0, 0, 0, 1

];

Integer x;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

x := F1;

r1024 := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

if (r1024 <= A[x, F1]) then

 x := F1;

 elseif (r1024 <= A[x, F1] + A[x, F2]) then

 x := F2;

 elseif (r1024 <= A[x, F1] + A[x, F2] + A[x, F3]) then

 x := F3;

 else

 x := End;

end if;

end when;

end System;




21) Si consideri un software sviluppato seguendo un approccio plan-driven implementato con tre fasi: F1, F2, F3. Le "change requests"  arrivano con probabilità p dopo ciascuna fase e provocano la ripetizione (con relativo costo) di tutte le fasi che precedono. Quali delle seguenti catene di Markov modella lo sviluppo software descritto.

1 OK




22) Una azienda finanziaria desidera costruire un sistema software per ottimizzare i processi di business. Quali delle seguenti attività può contribuire a validare i requisiti del sistema ?

Scegli un'alternativa:

1.
Costruire un prototipo del sistema e valutarne i requisiti non funzionali usando i dati storici dall'azienda.


2.
Costruire un prototipo del sistema e testarlo rispetto ai requisiti funzionali usando i dati storici dall'azienda.

3. OK
Costruire un modello di simulazione per i principali aspetti dei processi di business dell'azienda e per il sistema software da realizzare e valutare le migliorie apportate dal sistema software ai processi di business dell'azienda mediante simulazione.




23) Quale delle seguenti affermazioni è vera riguardo ai metodi agile ?


Scegli un'alternativa:

1. OK
I metodi agile sono metodi di sviluppo incrementale. 

2.
I metodi agile sono metodi di sviluppo plan-driven. 

3.
I metodi agile sono metodi di sviluppo orientato al riuso. 





24) Unit testing si concentra su:

Scegli un'alternativa:

1.
Testare l'interazione tra componenti.


2. OK
Testare funzionalità di unità software individuali, oggetti, classi o metodi.


3.
Testare le interfacce di ciascuna componente.




25) Il system testing si concentra su:


Scegli un'alternativa:

1.
Testare le funzionalità di unità software individuali, oggetti, classi o metodi.


2.
Testare le interfacce per ciascuna componente.

3. OK
Testare l'interazione tra  le componenti del sistema (cioè, integrazione di molte unità di sistema).





26) Si consideri l'ambiente (use case) che consiste di un utente che, ad ogni unità di tempo (ad esempio, un secondo) manda al nostro sistema input 1 (ad esempio, esegue una prenotazione) con probabilità 0.3 oppure input 0 con probabilità 0.7. Quale dei seguenti modelli Modelica rappresenta correttamente tale ambiente.

Scegli un'alternativa:

1. OK

model System

Integer y;

Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

equation

y = if (r1024 <= 0.3) then 1 else 0;

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

r1024     := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

end when;

end System;


2.


model System

Integer y;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

equation

y = if (r1024 <= 0.3) then 0 else 1;

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

r1024     := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

end when;

end System;


3.


model System

Integer y;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

equation

y = if (r1024 >= 0.3) then 1 else 0;

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

r1024     := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

end when;

end System;





27) Si consideri un software sviluppato seguendo un approccio iterativo implementato con due fasi: F1 seguita da F2. Ciascuna fase ha costo A e deve essere ripetuta una seconda volta con probabilità p. Qual'e' il costo atteso dello sviluppo dell'intero software?

Scegli un'alternativa:

1.
2*A*(p + 2)

2.
3*A*(p + 1)

3. OK
2*A*(p +1)





28) Un processo di sviluppo plan-driven consiste di 2 fasi F1, F2, ciascuna costo A. Alla fine di ogni fase vengono prese in considerazione le "change requests" e, se ve ne sono, lo sviluppo viene ripetuto a partire dalla prima iterazione.  Quindi con nessuna change request si hanno le fasi: F1, F2 e costo 2A. Con una "change request" dopo la prima fase si ha: F1, F1, F2 e costo 3A.  Con una change request dopo la fase 2 si ha: F1, F2, F1, F2 e costo 4A. Qual'è il costo nel caso in cui ci siano change requests sia dopo la fase 1 che dopo la fase 2.

Scegli un'alternativa:

1.
6*A

2.
7*A

3. OK
5*A





29) Si consideri il monitor seguente che ritorna true appena il sistema viola il requisito monitorato.

// block Monitor

input Real x;  

output Boolean y;

Boolean w;

initial equation

y = false;

equation

w = ((x < 1) or (x > 4)) and ((x < 15) or (x > 20));

algorithm

when edge(w) then

y := true;

end when;

end Monitor; //

Quale delle seguenti affermazioni meglio descrive il requisito monitorato?

Scegli un'alternativa:

1.
La variabile x è fuori dall'intervallo [1, 4] e fuori dall'intervallo [15, 20].


2. OK
La variabile x è nell'intervallo [1, 4] oppure nell'intervallo [15, 20].


3.
La variabile x è nell'intervallo [1, 4] e fuori dall'intervallo [15, 20].




30) Un I/O buffer è alimentato da una componente che fornisce un input periodico di periodo 2 secondi. Durante la prima metà del periodo, l'input rate è 2MB/s mentre durante la seconda metà del periodo l'input rate è 0. Quindi l'input rate medio è di 1MB/s. L' I/O buffer, a sua volta, alimenta una componente che richiede (in media) 1MB/s. Quale dei seguenti modelli Modelica  è un modello ragionevole per il sistema descritto sopra ?

Scegli un'alternativa:

1. OK

class System

Real x; // MB in buffer

Real u; // input pulse

initial equation

x = 3;

u = 0;

equation

when sample(0, 1) then

  u = 1 - pre(u);

end when;

der(x) = 2*u - 1.0;

end System;


2.


class System

Real x; // MB in buffer

Real u; // input pulse

initial equation

x = 3;

u = 0;

equation

when sample(0, 1) then

  u = 1 - pre(u);

end when;

der(x) = 2*u - 2.0;

end System;





3.


class System

Real x; // MB in buffer

Real u; // input pulse

initial equation

x = 3;

u = 0;

equation

when sample(0, 1) then

  u = 1 - pre(u);

end when;

der(x) = 2*u + 1.0;

end System;






31) Un processo di sviluppo agile consiste di varie iterazioni. Alla fine di ogni iterazione vengono prese in considerazione le "change requests" e, se ve ne sono, l'iterazione viene ripetuta. Sia p la probabilità che ci siano "change requests" all fine di una iterazione e sia A il costo di una iterazione. Il valore atteso del costo per l'iterazione è:

Scegli un'alternativa:

1. OK
(1 + p)*A

2.
A

3.
p*A




32) Una azienda manifatturiera desidera costruire un sistema software per monitorare (attraverso sensori) la produzione al fine di ridurre gli scarti. Quali delle seguenti attività contribuisce a validare i requisiti del sistema.

Scegli un'alternativa:

1. OK
Costruire un prototipo, eseguirlo usando dati storici dai log di produzione e valutare la capacità del prototipo di ridurre gli scarti.


2.
Costruire un prototipo, eseguirlo usando dati storici dai log di produzione e valutarne le performance.


3.
Costruire un prototipo, eseguirlo usando dati storici dai log di produzione ed identificare errori di implementazione.




33) Quale delle seguenti affermazioni è vera riguardo al performance testing?


Scegli un'alternativa:

1.
Il performance testing è tipicamente eseguito solo sulle componenti del sistema prima dell'integrazione.


2.
Il performance testing è tipicamente eseguito su un prototipo del sistema.

3. OK
Il performance testing è tipicamente eseguito una volta che il sistema è stato completamento integrato.





34) Quali delle seguenti attività è parte del processo di validazione dei requisiti ?

Scegli un'alternativa:

1.
Accertarsi che l'architettura del sistema soddisfi i requisiti dati. 


2.
Accertarsi che il sistema soddisfi i requisiti dati. 


3. OK
Accertarsi che i requisiti definiscano un sistema che risolve il problema che l'utente pianifica di risolvere.




35) Si consideri il Test-Driven Development (TDD). Quale delle seguenti affermazioni è vera?

Scegli un'alternativa:

1.
Per ciascun incremento di funzionalità, implementa la funzionalità, scrivi test automatizzati, esegui i test e rivedi l'implementazione come necessario.


2. OK
Per ciascun incremento di funzionalità, scrivi test automatizzati, implementa la funzionalità, esegui i test e rivedi l'implementazione come necessario.


3.
Scrivi test automatizzati per tutti i requisiti di sistema, esegui i test e rivedi l'implementazione come necessario.




36) Si consideri il seguente modello Modelica:

// class System

Integer x;

initial equation

x = 0;

equation

when sample(0, 2) then

    x = 1 - pre(x);

end when;

end System; //

Quale delle seguenti affermazioni è vera per la variabile intera x?

Scegli un'alternativa:

1.
Per tutti gli istanti di tempo della forma  3 + 4*k (con k = 0, 1, 2, 3, ...) x vale 1.


2.
Per tutti gli istanti di tempo della forma 1 + 4*k (con k = 0, 1, 2, 3, ...) x vale 0.


3. OK
Per tutti gli istanti di tempo della forma 1 + 4*k (con k = 0, 1, 2, 3, ...) x vale 1.



37) Si consideri l'ambiente (use case) consistente di un utente che ad ogni unità di tempo (ad esempio, un secondo) invia al nostro sistema input -1 con probabilità 0.2, input 0 con probabilità 0.5 ed input 1 con probabilità 0.3. Quale dei seguenti modelli Modelica rappresenta correttamente tale ambiente.

Scegli un'alternativa:

1. OK

model System

Integer y;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

equation

y = if (r1024 <= 0.2) then -1 else if (r1024 <= 0.7) then 0 else 1;

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

r1024     := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

end when;

end System;


2.

model System

Integer y;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

equation

y = if (r1024 <= 0.3) then -1 else if (r1024 <= 0.7) then 0 else 1;

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

r1024     := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

end when;

end System;


3.


model System

Integer y;  Real r1024;

Integer state1024[Modelica.Math.Random.Generators.Xorshift1024star.nState];

equation

y = if (r1024 <= 0.2) then -1 else if (r1024 <= 0.5) then 0 else 1;

algorithm

when initial() then

state1024 := Modelica.Math.Random.Generators.Xorshift1024star.initialState(614657, 30020);

r1024     := 0;

elsewhen sample(0,1) then

(r1024,state1024) := Modelica.Math.Random.Generators.Xorshift1024star.random(pre(state1024));

end when;

end System;




38) Quale delle seguenti frasi meglio descrive il criterio di "requirements verifiability" che è parte della "requirements validation activity".

Scegli un'alternativa:

1.
Per ciascuna componente del sistema, dovremmo essere in grado di scrivere un insieme di test che può dimostrare che essa soddisfa tutti i requisiti.


2. OK
Per ciascun requisito, dovremmo essere in grado di scrivere un inseme di test che può dimostrare che il sistema sviluppato soddisfa il requisito considerato.


3.
Per ciascuna coppia di componenti, dovremmo essere in grado di scrivere un insieme di test che può dimostrare che l'interazione tra le componenti soddisfa tutti i requisiti di interfaccia.






39) Si consideri un software costituito da due fasi F1 ed F2 ciascuna di costo A. Con probabilità p la fase F1 deve essere ripetuta (a causa di change requests) e con probabilità (1 - p) si passa alla fase F2 e poi al completamento (End) dello sviluppo. Qual'eè il costo atteso per lo sviluppo del software seguendo il processo sopra descritto ?



Scegli un'alternativa:

1.
3*A*p

2.
A*(1 + p)

3. OK
A*(2 + p)





40) "Ogni giorno, per ciascuna clinica, il sistema genererà una lista dei pazienti che hanno un appuntamento quel giorno."

La frase precedente è un esempio di:

Scegli un'alternativa:

1. OK
Requisito funzionale. 


2.
Requisito non-funzionale. 


3. 
Requisito di performance. 




















